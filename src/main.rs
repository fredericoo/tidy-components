mod config;
mod constants;

use std::fs;
use regex::Regex;
use std::io::prelude::*;


fn main() -> std::io::Result<()> {
    let config = config::read_config();
    index_dir(&config.base_path, &config, 0).expect("Failed indexing directory");

    Ok(())
}

fn index_dir(path: &str, config: &config::UserConfig, depth: i8) -> std::io::Result<()> {
    let mut exports: Vec<String> = Vec::new();
    println!("{}üìÅ /{}", 
        if depth > 0 { format!("{}{} ","‚îú‚îÄ","‚îÄ".repeat(((depth - 1) * 2) as usize)) } else { "".to_string() },
    path);
    for entry in fs::read_dir(path)? {
        let entry = entry?;
        let path = entry.path();
        if path.is_dir() {
            index_dir(path.to_str().unwrap(), config, depth+1)?;
        } else {
            let ext = path.extension().unwrap().to_str().unwrap();
            if config.file_exts.contains(&ext.to_string()) {
                index_file(&path, &mut exports).expect("Failed to index file");
            }
        }
    }

    create_index_file(&path, exports).expect("Failed to create index file");

    Ok(())
}

fn create_index_file(path: &str, exports: Vec<String>) -> std::io::Result<()> {
    println!("üìï Indexing directory: {}", path);

    let index_path = format!("{}/{}", path, "index.ts");

    let mut is_autogenerated = true;
    // read existing index file if exists, otherwise create it
    let mut index_file = match fs::File::open(index_path) {
        Ok(mut file) => {
            // set is_autogenerated to true when we can find the auto-generated header
            let mut buffer = [0; 32];
            file.read_exact(&mut buffer).expect("Failed to read index file");

            is_autogenerated = String::from_utf8_lossy(&buffer) == String::from_utf8_lossy(&constants::FILE_HEADER);
            file
        },
        Err(_) => {
            println!("‚îÇ  Creating index file");
            let index_path = format!("{}/{}", path, "index.ts");
            let mut file = fs::File::create(index_path).expect("Failed to create index file");
            file.write_all(&constants::FILE_HEADER).expect("Failed to write file header");
            file
        }
    };

    match is_autogenerated {
        true => {
            println!("‚îÇ  {} export(s) found for index", exports.len());
            for export in exports {
                index_file.write_all(format!("export {{ {} }} from \"./{}\";\n", export, export).as_bytes())?;
            }
        },
        false => {
            println!("‚îÇ  ‚ùå index.ts is not auto-generated, skipping");
        }
    }

    index_file.sync_all()?;
    
    Ok(())
}

fn index_file(path: &std::path::PathBuf, exports: &mut Vec<String>) -> std::io::Result<()> {
    // matches javascript's `export const ComponentName`
    let component_regex: regex::Regex = Regex::new(r"export (const|let|function) (?P<component>\w+)").unwrap();
    let file_stem = path.file_stem().unwrap().to_str().unwrap();
    
    let file = fs::read_to_string(path).expect("Unable to read file");
    // find all matches of the regex
    for caps in component_regex.captures_iter(&file) {
        if &caps["component"] == file_stem {
            println!("‚îú‚îÄ üß© {}", &caps["component"]);
            exports.push(file_stem.to_string())
        }
    }

    Ok(())
}