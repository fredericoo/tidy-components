mod config;
mod constants;

use std::fs;
use regex::Regex;
use std::io::prelude::*;


fn main() -> std::io::Result<()> {
    let config = config::read_config();
    index_dir(&config.base_path, &config).expect("Failed indexing directory");

    Ok(())
}

fn index_dir(path: &str, config: &config::UserConfig) -> std::io::Result<()> {
    let mut exports: Vec<String> = Vec::new();
    println!("Indexing directory: {}", path);
    for entry in fs::read_dir(path)? {
        let entry = entry?;
        let path = entry.path();
        if path.is_dir() {
            index_dir(path.to_str().unwrap(), config)?;
        } else {
            let ext = path.extension().unwrap().to_str().unwrap();
            if config.file_exts.contains(&ext.to_string()) {
                index_file(&path, &mut exports).expect("Failed to index file");
            }
        }
    }

    create_index_file(&path, exports).expect("Failed to create index file");

    Ok(())
}

fn create_index_file(path: &str, exports: Vec<String>) -> std::io::Result<()> {
    println!("Creating index file for: {}", path);

    std::env::set_current_dir(path).expect("Failed to change directory");

    let mut is_autogenerated = false;
    // read existing index file if exists, otherwise create it
    let mut index_file = match fs::File::open("index.ts") {
        Ok(file) => {
            // set is_autogenerated to true when we can find the auto-generated header
            let mut buffer = [0; 32];
            file.read_exact(&mut buffer).expect("Failed to read index file");
            is_autogenerated = buffer == constants::FILE_HEADER;
            file
        },
        Err(_) => {
            let mut file = fs::File::create("index.ts").expect("Failed to create index file");
            file.write_all(&constants::FILE_HEADER).expect("Failed to write file header");
            file
        }
    };

    match is_autogenerated {
        true => {
            for export in exports {
                index_file.write_all(format!("export {{ {} }} from \"./{}\";\n", export, export).as_bytes())?;
            }
            index_file.sync_all()?;
        },
        false => {
            println!("index.ts is not auto-generated, skipping");
        }
    }
    
    Ok(())
}

fn index_file(path: &std::path::PathBuf, exports: &mut Vec<String>) -> std::io::Result<()> {
    // matches javascript's `export const ComponentName`
    let component_regex: regex::Regex = Regex::new(r"export (const|let|function) (?P<component>\w+)").unwrap();
    let file_stem = path.file_stem().unwrap().to_str().unwrap();
    println!("Indexing component: {}", file_stem);
    
    let file = fs::read_to_string(path).expect("Unable to read file");
    // find all matches of the regex
    for caps in component_regex.captures_iter(&file) {
        if &caps["component"] == file_stem {
            println!("{} is a valid component", &caps["component"]);
            exports.push(file_stem.to_string())
        }
    }

    Ok(())
}